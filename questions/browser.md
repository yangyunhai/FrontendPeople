#### 1.`HTTP`与`HTTPS`的区别？

1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头

2.`HTTP` 是不安全的，而 HTTPS 是安全的

3.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443

4.在`OSI` 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层

5.`HTTP` 无法加密，而HTTPS 对传输的数据进行加密

6.`HTTP`无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

#### 2.`Http`的状态码有哪些?
* `200`：请求被正常处理
* `204`：请求被受理但没有资源可以返回
* `206`：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
* `301`：永久性重定向
* `302`：临时重定向
* `303`：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
* `304`：发送附带条件的请求时，条件不满足时返回，与重定向无关
* `307`：临时重定向，与302类似，只是强制要求使用POST方法
* `400`：请求报文语法有误，服务器无法识别
* `401`：请求需要认证
* `403`：请求的对应资源禁止被访问
* `404`：服务器无法找到对应资源
* `500`：服务器内部错误
* `503`：服务器超过最大负荷

#### 3.一次完整的`HTTP`事务是怎样一个过程？
1）域名解析

2） 发起`TCP`的3次握手

3） 建立`TCP`连接后发起`http`请求

4） 服务器响应`http`请求，浏览器得到html代码

5） 浏览器解析`html`代码，并请求`html`代码中的资源（如`js`、`css`、`图片`等）

6） 浏览器对页面进行渲染呈现给用户

#### 4.说说`304`缓存的原理?

1.服务器首先产生`ETag`，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存

2.`304`是`HTTP`状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

3.客户端请求一个页面（`A`）。 服务器返回页面A，并在给A加上一个`ETag`。 客户端展现该页面，并将页面连同`ETag`一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的`ETag`一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应`304`（未修改——`Not Modified`）和一个空的响应体

#### 5.为什么`HTTPS`安全?

因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用`HTTPS`，密钥在你和终点站才有。

`https`之所以比`http`安全，是因为他利用`ssl/tls`协议传输。

它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，`refer`传递等。保障了传输过程的安全性

#### 6.说说网络分层里七层模型是哪七层?

`应用层`：允许访问OSI环境的手段

`表示层`：对数据进行翻译、加密和压缩

`会话层`：建立、管理和终止会话

`传输层`：提供端到端的可靠报文传递和错误恢复

`网络层`：负责数据包从源到宿的传递和网际互连

`物理层`：通过媒介传输比特,确定机械及电气规范

#### 7.一个页面从输入 `URL` 到页面加载显示完成，这个过程中都发生了什么?

`01`.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存->系统缓存->路由器缓存->ISP DNS 缓存->根域名服务器)

`02`.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）

`03`.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com）

`04`.浏览器跟踪重定向地址，请求另一个带 www 的网址

`05`.服务器处理请求（通过路由读取资源）

`06`.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 'text/html'）

`07`.浏览器进 DOM 树构建

`08`.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）

`09`.浏览器显示完成页面

`10`.浏览器发送异步请求

#### 8.介绍下`http`缓存!

#### 缓存介绍：

缓存就是让同一份资源不再发起请求，降低网络压力和资源数量，从而让网页加载更快。
网络请求不稳定加剧了网页加载的不稳定性，所以需要缓存。
一般来说，js、css、img等静态资源可以被缓存

#### http缓存策略：
###### 强制缓存（Cache-Control）

![](https://img-blog.csdnimg.cn/20200620174738851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTY2NTQ3,size_16,color_FFFFFF,t_70#pic_center "")

`cache-control`在`response-headers`中，用于对缓存资源的控制，该属性可以控制强制缓存的逻辑，例如：`Cache-Control: max-age=31536000`(单位是秒)。
当再次请求时，先检查过期与否，若没有过期，则直接从缓存里拿数据，反之再次向服务器请求
Cache-Control的值：

* max-age （缓存的内容将在 xxx 秒后失效）
* no-cache（不用本地缓存）
* no-store（不用本地和服务端的缓存）

在现代浏览器中兼容`Expires`和`Cache-Control`，不过优先使用`Cache-Control`

###### 协商缓存（对比缓存）

![](https://img-blog.csdnimg.cn/20200620174705697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTY2NTQ3,size_16,color_FFFFFF,t_70#pic_center "")


协商缓存是服务端缓存策略（服务端判断该资源能否被缓存，而不是资源缓存在服务端），判断依据是客户端和服务端的资源标识是否一样，若一样则返回`304`，否则返回`200`和最新的资源、资源标识(资源标识在`response headers`中)

#### 资源标识：

`Last-Modified`（客户端再次请求时，`request headers`带着`if-Modified-Since`） 资源的最后修改时间

`Etag` 资源的唯一标识（客户端再次请求时，`request headers`带着`if-None-Match`）（一个字符串）
当两种资源标识共同存在时，优先使用`Etag`，因为`Last-Modified`只能精确到秒级，而`Etag`唯一


![](https://img-blog.csdnimg.cn/20200620174638203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTY2NTQ3,size_16,color_FFFFFF,t_70#pic_center "")


* 刷新操作方式，对缓存的影响：
* 正常操作：地址栏输入URL，跳转链接，前进后退等，强制缓存和协商缓存均有效
* 手动刷新：F5，点击刷新按钮，右键菜单刷新，强制缓存失效，协商缓存有效
* 强制刷新：ctrl+F5，强制缓存和协商缓存均无效



##### 9.`TCP` 为什么是三次握手，而不是两次或四次？
`TCP` 为什么是三次握手，而不是两次或四次？
>两次不安全，四次浪费资源。

三次握手，可以防止失效的连接请求报文段被服务端接收，从而产生错误。

所谓失效的连接请求，是指客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。

这样一个失效的连接请求，在网络中滞留许久后，到达服务端，服务端误以为是客户端再次发出的一个新的连接请求。

于是就向`client`发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要服务端发出确认，新的连接就建立了。由于现在客户端并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会向服务端发送数据。

但服务端却以为新的运输连接已经建立，并一直等待客户端发来数据。这样，服务端的很多资源就白白浪费掉了。

采用“`三次握手`”的办法可以防止上述现象发生。例如刚才那种情况，客户端不会向服务端发出确认。服务端由于收不到确认，就知道客户端并没有要求建立连接。。这样就避免服务端一直等待，浪费资源。


##### 10.`HTTP` 中 GET 与 `POST` 的区别

`GET`和`POST`是`HTTP`请求的两种基本方法，要说它们的区别，接触过`WEB`开发的人都能说出一二。

最直观的区别就是`GET`把参数包含在`URL`中,`POST`通过`request body`传递参数。

你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。

当你在面试中被问到这个问题，你的内心充满了自信和喜悦。

`1`.GET在浏览器回退时是无害的，而POST会再次提交请求。

`2`.GET产生的URL地址可以被Bookmark，而POST不可以

`3`.GET请求会被浏览器主动cache，而POST不会，除非手动设置。

`4`.GET请求只能进行url编码，而POST支持多种编码方式。

`5`.GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

`6`.GET请求在URL中传送的参数是有长度限制的，而POST么有。

`7`.对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

`8`.GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

`9`.GET参数通过URL传递，POST放在Request body中。

#### 11.从输入`URL`到页面加载发生了什么？

这个问题有没有觉得很眼熟，相信很多人在面试中都遇到过，这是一道非常非常经典的面试题！面试官喜欢问，是因为这道题真的可以考察很多方面的知识。

`1、`浏览器的地址栏输入URL并按下回车。

`2、`浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

`3、`DNS解析URL对应的IP。

`4、`根据IP建立TCP连接（三次握手）。

`5、`HTTP发起请求。

`6、`服务器处理请求，浏览器接收HTTP响应。

`7、`渲染页面，构建DOM树。

`8、`关闭TCP连接（四次挥手）。


如下流程图:
![](https://yangyunhaiimagesoss.oss-cn-shanghai.aliyuncs.com/2011091813_1604916792752.png)

#### 12.浏览器缓存原理是什么？
### 什么是缓存？
浏览器缓存(Brower Caching)是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力

http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。

HTTP 1.0协议中的。简而言之，就是告诉浏览器在约定的这个时间前，可以直接从缓存中获取资源（representations），而无需跑到服务器去获取。

网站访问速度对一个网站来说是非常重要的，访问慢会流失用户，访问快会大大的提高用户体验。

浏览器缓存大概有两种，`200 OK (from memory/disk cache)`和`304 Not Modified`各有各的优势，把他们发挥好可以大大的提升访问速度

### 强缓存200 OK (from memory/disk cache)

这种缓存方式已经很普遍，大部分网站的静态文件都采用了，200 OK (from memory cache)或者200 OK (from disk cache)都是直接读取客户端的缓存，无需再请求服务器。一般是在Apache或者Nginx里设置，比如Nginx配置里会有类似这样的配置：
```
 location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
 {
     expires      30d;
 }
 location ~ .*\.(js|css)?$
 {
     expires      12h;
 }
 ```

 这样就可以给静态文件缓存了，在有效期内，浏览器会直接读取客户端的缓存，而不用再请求服务器，除非用户清除了缓存或者使用Ctrl+F5强制刷新了页面。
 
 ![](https://yangyunhaiimagesoss.oss-cn-shanghai.aliyuncs.com/2011091742_1604914954114.gif)

 比如上图，是已经缓存过了的，至于有些是200 OK (from memory cache)有些会是200 OK (from disk cache)都差不多，只是从客户端取的位置不一样而已。除了给静态文件做200 OK (from cache)缓存外，其实我们也可以给某些页面做，比如一些不经常改变内容的ajax页面。

### 协商缓存304 Not Modified
向服务器发送请求，服务器会根据这个请求的 Request Headers 的一些参数(etag 和 last-modified)来判断是否命中协商缓存，如果命中，则返回 304 状态码, 并带上新的 Request Headers 通知浏览器从缓存中读取资源；

协商缓存主要表现在 Response Headers 中的 etag 和 last-modified：

![](https://yangyunhaiimagesoss.oss-cn-shanghai.aliyuncs.com/2011091750_1604915447310.jpg)


### 强缓存和协商缓存的header参数

`Expires`：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求
`Cache-Control`：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。
`cache-control`：除了该字段外，还有下面几个比较常用的设置值：
```
（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；

（2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；

（3）public：指示响应可被任何缓存区缓存；

（4）private：只能针对个人用户，而不能被代理服务器缓存；

（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上Cache-Control:     no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。

（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。
```


### 13. `xss`攻击和`csrf`攻击？

### 什么是XSS攻击？

`XSS`是跨站脚本攻击`(Cross Site Scripting)`，为不和层叠样式表`(Cascading Style Sheets, CSS)`的缩写混淆，故将跨站脚本攻击缩写为`XSS`。

恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。

### XSS的危害?
#### 1.窃取网页浏览中的cookie值

在网页浏览中我们常常涉及到用户登录，登录完毕之后服务端会返回一个cookie值。这个cookie值相当于一个令牌，拿着这张令牌就等同于证明了你是某个用户。

如果你的cookie值被窃取，那么攻击者很可能能够直接利用你的这张令牌不用密码就登录你的账户。如果想要通过script脚本获得当前页面的cookie值，通常会用到document.cookie。

试想下如果像空间说说中能够写入xss攻击语句，那岂不是看了你说说的人的号你都可以登录（不过某些厂商的cookie有其他验证措施如：Http-Only保证同一cookie不能被滥用）

#### 2.劫持流量实现恶意跳转

这个很简单，就是在网页中想办法插入一句像这样的语句：

```
<script>
window.location.href="http://www.baidu.com";
</script>
```
那么所访问的网站就会被跳转到百度的首页。

### XSS攻击大致上分为两类?
* 一类是反射型XSS，又称非持久型XSS，
* 一类是储存型XSS，也就是持久型XSS。

### 反射型XSS?

也就是攻击相对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。

也就是说想要触发漏洞，需要访问特定的链接才能够实现。

### 储存型XSS?
它与反射型XSS最大的不同就是服务器再接收到我们的恶意脚本时会将其做一些处理。

例如储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。

还记得在文章开头提到的留言板的例子吗？那通常就是储存型XSS。当有人在留言内容中插入恶意脚本时，由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪。

这个过程一般而言只要用户访问这个界面就行了，不像反射型XSS，需要访问特定的URL。

## 什么是csrf攻击?

这也是一种常见的网站攻击手段，它主要利用的是我们网站对于用户的信任。

**什么意思呢？**简单讲就是你刚刚登陆了腾讯充值中心，登陆充钱完了，你就关掉网站了，换了另外一个网站`www.qq.com`。

然后这个网站里面有个图片或者是超链接，这个url是`www.qq.com/chongzhizhongxin/pay?accout=xiaomizhou&number=10000`；（我们假设这是qq充值中心对于充值的api接口，现实中肯定不是这样也没有这么简单）。只要你点击了这个按钮，你就会向小米粥账户充值10000个q币了。

#### 为什么能够这样呢？

因为你刚刚登陆过qq充值系统不久，登陆状态还没有消失，信息都还在，所以能够直接调用接口进行支付。在这个过程中，黑客没办法知道你的用户信息，支付密码，甚至你的账户。但是凭借着qq充值网站对于用户的信任，以为这是你本人的操作，所以执行了。

#### 那么怎么防御呢？

只要我们开发人员，在一些重要的接口上设置一个验证过程，而这个验证是需要在qq充值中心网页的一个随机码（可以是时间戳加密），然后通过一系列的加密才能够获得。

而csrf攻击是在`www.qq.com`上发布出来的，没有进入到qq充值中心，所以无法获得这个随机数，从而调用接口的时候这个部分的信息为空或者错误，然后调用失败。


#### 14.如何进行网站性能优化？

### 一、减少请求资源大小或者次数
1、尽量和并和压缩css和js文件。（将css文件和并为一个。将js合并为一个）

>原因：主要是为了减少http请求次数以及减少请求资源的大小打包工具：webpack

2、尽量所使用的字体图标或者SVG图标来代替传统png图,因为字体图标或者SVG是矢量图，代码编写出来的，方大不会变形，而且渲染速度快

3、采用图片的懒加载（延迟加载）,目的为了，减少页面第一次加载过程中http的请求次数

#### 具体步骤：
1、页面开始加载时不去发送http请求，而是放置一张占位图

2、当页面加载完时，并且图片在可视区域再去请求加载图片信息

4、能用css做的效果，不要用js做，能用原生js做的，不要轻易去使用第三方插件。

#### 避免引入第三方大量的库。而自己却只是用里面的一个小功能

5、使用雪碧图或者是说图片精灵 把所有相对较小的资源图片，绘制在一张大图上，只需要将大图下载下来，然后利用 图片定位来讲小图展现在页面中（background-position:百分比，数值）

6、减少对cookie的使用（最主要的就是减少本地cookie存储内容的大小），因为客户端操作cookie的时候，这些信息总是在客户端和服务端传递。如果上设置不当，每次发送一个请求将会携带cookie

7、前端与后端进行数据交互时，对于多项数据尽可能基于json格式来进行传送。相对于使用xml来说传输有这个优势

#### 目的：是数据处理方便，资源偏小

8、前端与后端协商，合理使用keep-alive

9、前端与服务器协商，使用响应资源的压缩

10、避免使用iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源

11、在基于ajax的get请求进行数据交互的时候，根据需求可以让其产生缓存（注意:这个 缓存不是我们常看到的304状态码，去浏览器本地取数据），这样在下一次从相同地址获取是数据 时，取得就是上一次缓存的数据。（注意：很少使用，一般都会清空。根据需求来做）

### 二、代码优化相关


1、在js中尽量减少闭包的使用 原因：使用闭包后，闭包所在的上下文不会被释放

2、减少对DOM操作，主要是减少DOM的重绘与回流（重排）

>关于重排（回流）的分离读写：如果需要设置多个样式，把设置样式全放在一起设置，不要一条一条的设置。使用文档碎片或者字符串拼接做数据绑定（DOM的动态创建）

3、在js中避免嵌套循环和"死循环"(一旦遇到死循环，浏览器就会直接卡掉)

4、把css放在body上，把js放在body下面 让其先加载css（注意：这里关于优化没有多大关系）

5、减少css表达式的使用

6、css选择器解析规则所示从右往左解析的。减少元素标签作为对后一个选择对象

7、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小）

>注意：图层不要过多设置，否则不但效果没有达到反而更差了

8、在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码

9、css中设置定位后，最好使用z-index改变盒子的层级，让盒子不在相同的平面上

10、css导入的时候尽量减少@import导入式，因为@import是同步操作，只有把对应的样式导入后，才会继续向下加兹安，而link是异步的操作

11、使用window.requestAnimationFrame(js的帧动画)代替传统的定时器动画 如果想使用每隔一段时间执行动画，应该避免使用setInterval

>尽量使用setTimeout代替setInterval定时器。因为setInterval定时器存在弊端：可能造成两个动画间隔时间缩短

12、尽量减少使用递归。避免死递归 解决：建议使用尾递归

13、基于script标签下载js文件时，可以使用defer或者async来异步加载

14、在事件绑定中，尽可能使用事件委托，减少循环给DOM元素绑定事件处理函数。

15、在js封装过程中，尽量做到低耦合高内聚。减少页面的冗余代码

16、减少Flash的使用

### 三、存储
1、结合后端，利用浏览器的缓存技术，做一些缓存（让后端返回304，告诉浏览器去本地拉取数据）。（注意：也有弊端）可以让一些不太会改变的静态资源做缓存。比如：一些图片，js，cs

2、利用h5的新特性（localStorage、sessionStorage）做一些简单数据的存储， 避免向后台请求数据或者说在离线状态下做一些数据展示。

### 四、其他优化
1、避免使用iframe不仅不好管控样式，而且相当于在本页面又嵌套其他页面，消耗性能会更大。因为还回去加载这个嵌套页面的资源

2、页面中的是数据获取采用异步编程和延迟分批加载，使用异步加载是数据主要是为了避免浏览器失去响应。如果你使用同步，加载数据很大并且很慢

那么，页面会在一段时间内处于阻塞状态。目的：为了解决请求数据不耽搁渲染，提高页面的 渲染效率。

#### 解决方法：
需要动态绑定的是数据区域先隐藏，等数据返回并且绑定后在让其显示延迟分批加载类似图片懒加载。

减少第一次页面加载时候的http请求次数

3、页面中出现音视频标签，我们不让页面加载的时候去加载这些资源（否则第一次加载会很慢）

解决方法：
只需要将音视频的preload=none即可。

目的：为了等待页面加载完成时，并且音视频要播放的时候去加兹安音视频资源

4、尽量将一个动画元素单独设置为一个图层（避免重绘或者回流的大小） 注意：图层不要过多设置，否则不但效果没有达到反而更差了